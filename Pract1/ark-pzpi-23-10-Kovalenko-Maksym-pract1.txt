Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії










Звіт                                        
Практична робота №1
з дисципліни: « Аналіз та рефакторинг коду »
на тему: Правила оформлення програмного коду в Pascal












Виконав:
ст.гр. ПЗПІ-23-10
Коваленко Максим
	Перевірив:
ст. викладач катедри ПІ
Сокорчук Ігор Петрович
	











Харків 2025
 
«Використання SIMD команд при розробці програм»


1 ІСТОРІЯ ЗМІН
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	22.10.2025
	0.1
	Створено структуру звіту, розділ 2
	2
	22.10.2025
	0.2
	Додано розділ 3 (Опис роботи)
	3
	22.10.2025
	0.3
	Додано розділи 4, 5 та Додатки А, Б, В
	4
	22.10.2025 
	1.0
	Фінальне форматування
	

2 ЗАВДАННЯ
Дослідити основні рекомендації щодо оформлення програмного коду мовою Pascal. Проаналізувати принципи структурування коду, форматування, іменування змінних, функцій та типів, використання коментарів та документування. Розглянути специфічні конвенції мови Pascal, основи кодування на основі тестування (TDD) та інструменти, що допомагають підтримувати якість коду. Навести приклади коду, що ілюструють застосування правил оформлення.
Підготувати звіт, презентацію та відеозапис доповіді згідно з методичними вказівками.
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ: Важливість правил оформлення коду
Правила оформлення програмного коду є важливим аспектом розробки програмного забезпечення. Їх дотримання має низку переваг:
Полегшення читання та розуміння коду: Стандартизований код легше сприймається як іншими розробниками, так і автором коду через деякий час.


Спрощення командної роботи: Єдиний стиль кодування усуває розбіжності та непорозуміння, дозволяючи команді ефективніше взаємодіяти над проєктом.


Зменшення кількості помилок: Чіткий та структурований код простіше аналізувати, тестувати та налагоджувати, що допомагає виявляти помилки на ранніх етапах.


Полегшення підтримки та модифікації: Зрозумілий код легше модифікувати, розширювати та виправляти в ньому помилки протягом життєвого циклу програмного продукту.
Мова Pascal сама по собі є структурованою, що сприяє певному порядку в коді завдяки чіткому поділу на секції. Однак, послідовне дотримання додаткових правил оформлення значно покращує якість коду.
3.2 Структура коду в Pascal
Програма або модуль (unit) на Pascal має чітку структуру, що включає декілька основних секцій:
program / unit: Заголовок програми або модуля.


uses: Секція підключення зовнішніх модулів (бібліотек).


const: Секція оголошення констант.


type: Секція оголошення користувацьких типів даних (записи, масиви, класи тощо).


var: Секція оголошення глобальних змінних.


procedure / function: Секція оголошення та реалізації підпрограм (процедур та функцій).


begin ... end.: Основний блок програми (для файлу program) або секція ініціалізації/фіналізації (для unit).
Модулі (unit) дозволяють логічно групувати пов'язаний код (функції, типи, константи) в окремих файлах для повторного використання та кращої організації проєкту.
Приклад структури простої програми наведено у Додатку В (В.1).


3.3 Форматування коду
Правильне форматування значно покращує читабельність коду:
* Відступи (Indentation): Зазвичай використовується 2 або 4 пробіли для кожного нового рівня вкладеності (тіло циклів for, while; блоки умов if; блоки begin/end). Найважливіше – бути послідовним у виборі стилю відступів у межах одного проєкту.
* Розташування begin/end: Блок begin часто розміщують на тому ж рядку після ключового слова конструкції (if, for) або на наступному рядку з відступом. Ключове слово end вирівнюється вертикально з відповідним begin.
* Довжина рядка: Рекомендується обмежувати довжину рядка коду (наприклад, 80 або 120 символами), щоб уникнути горизонтальної прокрутки. Довгі вирази слід переносити на новий рядок з додатковим відступом.
Приклади коду з правильними відступами наведено у Додатку В (В.2).


3.4 Іменування
Вибір змістовних імен для змінних, констант, типів, процедур та функцій є одним з найважливіших аспектів написання чистого коду:
Принципи: Імена повинні чітко відображати призначення елемента коду. Слід уникати скорочень, абревіатур та однолітерних імен (за винятком лічильників циклів, таких як i, j, k).
Конвенції (поширені стилі):
Змінні: camelCase (maxCount) або PascalCase (MaxCount).


Константи: UPPER_SNAKE_CASE (MAX_BUFFER_SIZE) або PascalCase (MaxBufferSize).


Типи (record, class): PascalCase, часто з префіксом T (традиція Object Pascal/Delphi), наприклад, TStudentProfile.


Процедури та функції: PascalCase, часто починаючи з дієслова, що описує дію (CalculateAverage, PrintDocument).


"Магічні" числа: Числа, що з'являються в коді без пояснення, слід замінювати іменованими константами для покращення зрозумілості та полегшення змін у майбутньому.
Приклади хороших і поганих імен, а також використання констант замість "магічних" чисел наведено у Додатку В (В.3).


3.5 Коментарі
Коментарі слугують для пояснення коду, але їх слід використовувати обережно:
Синтаксис у Pascal: { ... }, (* ... *), // ... (до кінця рядка).


Призначення: Коментарі мають пояснювати навіщо щось зроблено (складний алгоритм, неочевидне рішення), а не що робить код (це має бути зрозуміло з самого коду та імен).


Корисні коментарі: Пояснення складних регулярних виразів, бізнес-логіки, позначки TODO або FIXME для майбутніх доробок.


Чого уникати: Надлишкових коментарів, що дублюють код; закоментованого "мертвого" коду; неактуальних коментарів, що не відповідають поточному стану коду.
Приклад поганого коментаря: i := i + 1; // Збільшення і на 1.


3.6 Документування коду
Документаційні коментарі описують, як використовувати певний елемент коду (процедуру, функцію, модуль):
Відмінність від звичайних коментарів: Описують інтерфейс (параметри, що повертається, призначення), а не внутрішню реалізацію.


Стандарти: У Pascal немає єдиного стандарту. У середовищах Delphi/Lazarus використовуються спеціальні XML-теги або структуровані багаторядкові коментарі. Інструменти типу PasDoc можуть генерувати документацію на основі таких коментарів.


Зміст: Зазвичай включають опис призначення, параметрів (@param), значення, що повертається (@return), можливі винятки (@throws), автора (@author), версію (@version).
Приклад документаційного коментаря наведено у Додатку В (В.4).


3.7 Специфічні конвенції Pascal
Окрім загальних правил, існують особливості, характерні для Pascal:
Структура модулів (unit): Чіткий поділ на interface (публічна частина) та implementation (приватна реалізація).


Нечутливість до регістру: Pascal не розрізняє великі та малі літери в іменах, але для читабельності слід дотримуватись єдиного стилю.


Секція uses: Підключати лише необхідні модулі, розміщувати на початку файлу.
Обробка винятків: У сучасних версіях (Delphi, Free Pascal) використовувати try...except та try...finally для надійної обробки помилок та управління ресурсами.




3.8 Кодування на основі тестування (TDD)


Test-Driven Development (TDD) – це підхід, де тести пишуться перед кодом:
Цикл TDD: Написати тест (не проходить) -> Написати код (тест проходить) -> Покращити код (рефакторинг).


Переваги: Заохочує модульний дизайн, код стає більш тестованим та надійним.


Інструменти: Для Pascal існують фреймворки юніт-тестування, такі як FPCUnit (для Free Pascal/Lazarus) та DUnit (для Delphi).


Написання тестів: Тести мають бути маленькими, швидкими, незалежними, перевіряти результат роботи та покривати граничні випадки.


3.9 Інструменти та Автоматизація
Існують інструменти, що допомагають підтримувати якість коду:
Форматери коду: Автоматично виправляють стиль (відступи, пробіли). Приклади: вбудовані в IDE (Lazarus, Delphi), JEDI Code Format.


Статичні аналізатори: Шукають потенційні помилки та порушення стилю без запуску коду. Приклад: Pascal Analyzer.


Системи контролю версій (Git): Дозволяють відстежувати зміни, працювати в команді. Можливе налаштування Git Hooks для автоматичних перевірок.


IDE (Lazarus, Delphi): Надають автодоповнення, підказки, інструменти рефакторингу.


3.10 Приклад застосування правил
Для демонстрації впливу правил оформлення було взято фрагмент коду з поганим стилем та переписано його з дотриманням рекомендацій щодо іменування, відступів, використання констант та пробілів. Код "до" та "після" наведено у Додатку В (В.5). Зміни значно покращили читабельність та зрозумілість коду.


4 ВИСНОВКИ
У ході виконання практичного завдання було розглянуто основні правила та рекомендації щодо оформлення програмного коду мовою Pascal. Було досліджено важливість стандартизації стилю кодування для покращення читабельності, спрощення командної роботи, зменшення кількості помилок та полегшення підтримки програмного забезпечення.
Отримано навички застосування правил щодо структурування коду, форматування (відступи, довжина рядка), іменування ідентифікаторів (змінних, констант, типів, процедур, функцій), використання коментарів та документування. Розглянуто специфічні конвенції мови Pascal, основи підходу Test-Driven Development та інструменти, що допомагають автоматизувати підтримку якості коду.
Аналіз прикладів коду "до" та "після" застосування правил показав значне покращення зрозумілості та структурованості коду. Дотримання цих правил є важливою практикою для будь-якого розробника, що прагне створювати якісне та підтримуване програмне забезпечення.
5 ВИКОРИСТАНІ ДЖЕРЕЛА


1. Programming Style [електронний ресурс] // Free Pascal Wiki. URL: https://wiki.freepascal.org/Programming_Style (дата звернення: 22.10.2025). 
2. 2Coding Standards [електронний ресурс] // Delphi Basics. URL: http://www.delphibasics.co.uk/Article.asp?Name=CodingStandards (дата звернення: 22.10.2025). 
3. Pascal - Coding Style [електронний ресурс] // TutorialsPoint. URL: https://www.tutorialspoint.com/pascal/pascal_coding_style.htm (дата звернення: 22.10.2025).
4.  Pascal Programming Style [електронний ресурс] // GeeksforGeeks. URL: https://www.geeksforgeeks.org/pascal-programming-style/ (дата звернення: 22.10.2025).










ДОДАТОК А 
Відеозапис
Відеозапис доповіді до практичного завдання №1 доступний за посиланням: https://www.youtube.com/watch?v=WLDV53033_k


Хронологічний опис відеозапису:
00:00 – Привітання 
00:10 – Вступ
00:45 – Структура коду в Pascal 
01:36 – Форматування: відступи та довжина рядка 
02:53 – Іменування 
03:53 – Коментарі 
04:50 – Документування коду 
05:35 – Конвенції стилю 
06:38 – Кодування на основі тестування 
07:39 – Інструменти та автоматизація 
08:42 – Приклади оформлення коду 
09:39 – Висновки
































ДОДАТОК Б 
Слайди презентації
  

Рисунок Б.1 – Титульний слайд
  

Рисунок Б.2 – Вступ: Важливість правил оформлення
  

Рисунок Б.3 – Структура коду в Pascal
  

Рисунок Б.4 – Форматування: Відступи та довжина рядка
________________


  

Рисунок Б.5 – Іменування: Робимо код зрозумілим
  

Рисунок Б.6 – Форматування: Відступи та довжина рядка


  

Рисунок Б.7 – Документування коду
  

Рисунок Б.8 – Конвенції стилю для Pascal


  

Рисунок Б.9 – Кодування на основі тестування
  

Рисунок Б.10 – Інструменти та Автоматизація
  

Рисунок Б.11 – Приклади оформлення коду


  

Рисунок Б.12 – Висновки


  

Рисунок Б.13 – Використані джерела


















ДОДАТОК В 
Програмний код
В.1 Приклад структури програми Pascal
GitHub репозиторій: https://github.com/NureKovalenkoMaksym/ark-pzpi-23-10-kovalenko-maksym/blob/main/Pract1/codesamples/structure_example.pas


1 program StructureExample; // Заголовок програми
2 uses Crt;                // Секція підключення модулів
3
4 const
5   MaxItems = 100;        // Секція констант
6
7 type
8   TItem = record         // Секція типів
9     ID: Integer;
10     Name: String;
11   end;
12
13 var
14   itemsList: array[1..MaxItems] of TItem; // Секція змінних
15   itemCount: Integer;
16
17 procedure InitializeItems; // Секція процедур та функцій
18 begin
19   itemCount := 0;
20   WriteLn('Item list initialized.');
21 end;
22
23 begin // Основний блок програми
24   InitializeItems;
25   WriteLn('Program structure example.');
26   // ... інший код ...
27   ReadKey;
28 end. // Кінець програми


В.2 Приклад форматування коду (відступи)
GitHub репозиторій: https://github.com/NureKovalenkoMaksym/ark-pzpi-23-10-kovalenko-maksym/blob/main/Pract1/codesamples/structure_example.pas


1 // Приклад з умовою IF
2 if (temperature > 20) and (isSunny) then
3 begin
4   WriteLn('Good weather for a walk.'); // Відступ всередині блоку
5   activity := 'Walking';
6 end
7 else
8 begin
9   WriteLn('Maybe stay indoors.');
10   activity := 'Reading';
11 end; // Кінець блоку на рівні IF/ELSE
12
13 // Приклад з циклом FOR
14 sum := 0;
15 for i := 1 to 10 do
16 begin // Початок блоку циклу
17   sum := sum + i; // Відступ для тіла циклу
18   WriteLn('Current sum: ', sum);
19 end; // Кінець блоку на рівні FOR


В.3 Приклади іменування
GitHub репозиторій: https://github.com/NureKovalenkoMaksym/ark-pzpi-23-10-kovalenko-maksym/blob/main/Pract1/codesamples/structure_example.pas
1 // Погані імена
2 var
3   a, b, c: Integer; // Незрозуміло, що зберігають
4   tempVal: Real;    // "temp" часто малоінформативне
5   proc1: procedure; // Назва не каже, що робить процедура
6
7 // Хороші імена (наприклад, PascalCase для типів/функцій, camelCase для змінних)
8 const
9   MaxAttempts = 3; // Константа великими літерами або PascalCase
10 type
11   TUserProfile = record // Тип запису з префіксом T і PascalCase
12     userId: Integer;
13     userName: string[50];
14     isActive: Boolean;
15   end;
16 var
17   currentUser: TUserProfile; // Змінна camelCase або PascalCase
18   loginAttempts: Integer;
19
20 procedure CheckLoginCredentials(name: string; pass: string); // Назва процедури описує дію
21 begin
22   // ... логіка перевірки ...
23 end;
24
25 // Приклад з "магічним" числом
26 // Погано - що таке 100?
27 if score > 100 then
28   isWinner := True;
29
30 // Добре - зрозуміло, що це порогове значення
31 const
32   WinningScoreThreshold = 100;
33 begin
34   if score > WinningScoreThreshold then
35     isWinner := True;
36 end;


В.4 Приклад документування коду
GitHub репозиторій: https://github.com/NureKovalenkoMaksym/ark-pzpi-23-10-kovalenko-maksym/blob/main/Pract1/codesamples/structure_example.pas
1 {-----------------------------------------------------------------------
 2   Procedure: ClearUserData
 3   Purpose:   Resets the user profile data to default values.
 4   Params:    user - The TUserProfile record to clear.
 5   Modified:  2025-10-22 by Maksym Kovalenko
 6  -----------------------------------------------------------------------}
 7 procedure ClearUserData(var user: TUserProfile);
 8 begin
 9   user.userId := 0;
10   user.userName := '';
11   user.isActive := False;
12 end;
13
14 {***
15   Function: GetUserStatus
16   Returns the active status of a user profile.
17   @param user The user profile record.
18   @return True if user is active, False otherwise.
19 ***}
20 function GetUserStatus(user: TUserProfile): Boolean;
21 begin
22   Result := user.isActive;
23 end;






В.5 Конвенції стилю для Pascal
GitHub репозиторій: https://github.com/NureKovalenkoMaksym/ark-pzpi-23-10-kovalenko-maksym/blob/main/Pract1/codesamples/structure_example.pas
1 try
2   // Код, що може викликати помилку
3   result := CalculateSomethingRisky;
4 except
5   on E: Exception do // Обробка конкретного винятку
6     WriteLn('An error occurred: ', E.Message);
7 end;


В.6 Кодування на основі тестування
GitHub репозиторій: https://github.com/NureKovalenkoMaksym/ark-pzpi-23-10-kovalenko-maksym/blob/main/Pract1/codesamples/structure_example.pas
1 // Уявімо, що ми хочемо протестувати функцію Factorial
2 // Спочатку пишемо тест (у тестовому модулі)
3 procedure TTestMathUtils.TestFactorial_Zero;
4 begin
5   // Перевіряємо, чи Factorial(0) повертає 1
6   CheckEquals(1, Factorial(0), 'Factorial of 0 should be 1');
7 end;
8
9 procedure TTestMathUtils.TestFactorial_Positive;
10 begin
11   // Перевіряємо, чи Factorial(5) повертає 120
12   CheckEquals(120, Factorial(5), 'Factorial of 5 should be 120');
13 end;
14
15 // Потім пишемо саму функцію Factorial так, щоб ці тести пройшли.


В.7 Приклад коду "До" та "Після" оформлення
GitHub репозиторій: https://github.com/NureKovalenkoMaksym/ark-pzpi-23-10-kovalenko-maksym/blob/main/Pract1/codesamples/structure_example.pas


1 // Код ДО застосування правил (важко читати):
2 function calc(a:integer; b:integer):integer;
3 var res:integer; t:integer;
4 begin
5 t:=a+b; if t>10 then res:=t*2 else res:=t+5;
6 calc:=res; end; // Все в один рядок, незрозумілі імена
7
8 // Той самий код ПІСЛЯ застосування правил:
9 // Функція обчислює значення залежно від суми вхідних параметрів
10 function CalculateValue(param1: Integer; param2: Integer): Integer;
11 var
12   sumValue: Integer;    // Змістовне ім'я
13   resultValue: Integer; // Змістовне ім'я
14 const
15   Threshold = 10;      // "Магічне" число винесено в константу
16   Multiplier = 2;
17   Addition = 5;
18 begin
19   sumValue := param1 + param2; // Відступи та пробіли
20
21   if sumValue > Threshold then // Використання константи
22   begin // Відступи для блоку
23     resultValue := sumValue * Multiplier;
24   end
25   else
26   begin
27     resultValue := sumValue + Addition;
28   end;
29
30   CalculateValue := resultValue; // Повернення результату (старий стиль Pascal)
31   // Або: Result := resultValue; (сучасний стиль Free Pascal/Delphi)
32 end;
































































































________________